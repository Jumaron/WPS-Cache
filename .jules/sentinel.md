## 2024-05-23 - Authenticated SSRF in Cache Preloader
**Vulnerability:** The Cache Preloader (`ToolsManager.php`, `CacheTools.php`, `CronManager.php`) used `wp_remote_get` with `sslverify => false` and did not validate the target URL. This allowed an authenticated administrator (or an attacker via CSRF/XSS, although nonces were present) to force the server to make HTTP requests to arbitrary internal or external URLs. This could be used to scan internal networks or access cloud metadata services.
**Learning:** Even when functionality is intended to "self-ping" (preload cache), assuming the URL is safe or that the server can access itself safely via public DNS is risky. `wp_remote_get` by default allows requests to local IPs unless filtered.
**Prevention:** Use `wp_safe_remote_get()` for any HTTP request where the URL might be influenced by user input or where safety from SSRF is required. This function blocks requests to private IP ranges and local network addresses. Also, never disable SSL verification (`sslverify => false`) in production code.

## 2024-05-24 - PHP Object Injection in Redis Object Cache
**Vulnerability:** The `object-cache.php` drop-in blindly `unserialize()`-ed data retrieved from Redis matching the standard serialization pattern (`/^[absiOCrdN]:[0-9]+/`). If an attacker could inject data into Redis (Cache Poisoning), they could trigger PHP Object Injection chains, leading to RCE.
**Learning:** Data in a remote store (like Redis) should not be inherently trusted as "safe," especially in shared hosting or environments where the cache store might be accessible to other services.
**Prevention:** Implement HMAC-SHA256 signing for all serialized data before storing it. Verify the signature before unserializing. Reject any legacy or unsigned data that looks like a serialized object. Treat primitives (strings/ints) as raw values to maintain performance and atomic operations.
